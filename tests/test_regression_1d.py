"""Full-pipeline regression test for the 1D maze analysis.

Runs the complete MazeDataset pipeline on a small data subset and
compares every output against a saved reference bundle.  The reference
was generated by ``generate_regression_data_1d.py`` (one-time, requires
ProcData drive).
"""

from pathlib import Path

import numpy as np
import pytest

from placecell.dataset import BasePlaceCellDataset
from placecell.maze_dataset import MazeDataset

REGRESSION_DIR = Path(__file__).parent / "assets" / "regression_1d"


@pytest.fixture(scope="module")
def pipeline_result() -> MazeDataset:
    """Run the full 1D maze pipeline once for all tests in this module."""
    ds = BasePlaceCellDataset.from_yaml(
        REGRESSION_DIR / "analysis_config.yaml",
        REGRESSION_DIR / "data_paths.yaml",
    )
    assert isinstance(ds, MazeDataset)
    ds.load()
    ds.preprocess_behavior()
    ds.deconvolve()
    ds.match_events()
    ds.compute_occupancy()
    ds.analyze_units()
    return ds


@pytest.fixture(scope="module")
def reference() -> MazeDataset:
    """Load the reference bundle."""
    ds = BasePlaceCellDataset.load_bundle(REGRESSION_DIR / "reference.pcellbundle")
    assert isinstance(ds, MazeDataset)
    return ds


# ── Summary ──────────────────────────────────────────────────────────


@pytest.mark.timeout(120)
def test_summary_counts(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Pipeline summary counts must match the reference."""
    assert pipeline_result.summary() == reference.summary()


# ── Deconvolution ────────────────────────────────────────────────────


def test_good_unit_ids(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Deconvolved unit IDs must match."""
    assert pipeline_result.good_unit_ids == reference.good_unit_ids


def test_event_index_shape(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Non-trivial event count must match.

    OASIS deconvolution can produce near-zero ghost events (s ~ 1e-17)
    whose presence varies across platforms.  Filter these out before
    comparing counts.
    """
    threshold = 1e-10
    got = (pipeline_result.event_index["s"] > threshold).sum()
    ref = (reference.event_index["s"] > threshold).sum()
    assert got == ref


# ── Event–place matching ─────────────────────────────────────────────


def test_event_place_shape(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Non-trivial matched event count must match (see event_index note)."""
    threshold = 1e-10
    got = (pipeline_result.event_place["s"] > threshold).sum()
    ref = (reference.event_place["s"] > threshold).sum()
    assert got == ref


def test_event_place_has_pos_1d(
    pipeline_result: MazeDataset,
) -> None:
    """Matched events must have pos_1d column from 1D matching."""
    assert "pos_1d" in pipeline_result.event_place.columns
    assert pipeline_result.event_place["pos_1d"].notna().all()


# ── 1D trajectory ────────────────────────────────────────────────────


def test_trajectory_1d_shape(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """1D trajectory frame count must match."""
    assert len(pipeline_result.trajectory_1d) == len(reference.trajectory_1d)


def test_trajectory_1d_filtered_shape(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Speed-filtered 1D trajectory frame count must match."""
    assert len(pipeline_result.trajectory_1d_filtered) == len(
        reference.trajectory_1d_filtered
    )


def test_arm_boundaries(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Arm boundaries must match reference."""
    np.testing.assert_allclose(
        pipeline_result.arm_boundaries,
        reference.arm_boundaries,
        rtol=1e-5,
    )


def test_effective_arm_order(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Effective arm order (with direction splits) must match."""
    assert pipeline_result.effective_arm_order == reference.effective_arm_order


def test_pos_range(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Position range must match reference."""
    np.testing.assert_allclose(
        pipeline_result.pos_range,
        reference.pos_range,
        rtol=1e-5,
    )


# ── Occupancy ────────────────────────────────────────────────────────


def test_occupancy_map(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """1D occupancy map must match reference."""
    np.testing.assert_allclose(
        pipeline_result.occupancy_time,
        reference.occupancy_time,
        rtol=1e-5,
    )


def test_valid_mask(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Valid mask must match reference."""
    np.testing.assert_array_equal(
        pipeline_result.valid_mask,
        reference.valid_mask,
    )


def test_edges_1d(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """1D bin edges must match reference."""
    np.testing.assert_allclose(
        pipeline_result.edges_1d,
        reference.edges_1d,
        rtol=1e-5,
    )


# ── Per-unit analysis results ────────────────────────────────────────


def test_unit_result_ids(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Analyzed unit IDs must match."""
    assert sorted(pipeline_result.unit_results.keys()) == sorted(
        reference.unit_results.keys()
    )


def test_unit_scalars(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Per-unit scalar metrics (SI, p_val, stability) must match."""
    for uid in reference.unit_results:
        ref = reference.unit_results[uid]
        got = pipeline_result.unit_results[uid]

        assert got.si == pytest.approx(ref.si, rel=1e-5), f"unit {uid} SI"
        assert got.p_val == pytest.approx(ref.p_val, rel=1e-5), f"unit {uid} p_val"
        assert got.stability_corr == pytest.approx(
            ref.stability_corr, nan_ok=True, rel=1e-5
        ), f"unit {uid} stability_corr"
        assert got.stability_z == pytest.approx(
            ref.stability_z, nan_ok=True, rel=1e-5
        ), f"unit {uid} stability_z"
        assert got.stability_p_val == pytest.approx(
            ref.stability_p_val, nan_ok=True, rel=1e-5
        ), f"unit {uid} stability_p_val"


def test_rate_maps(
    pipeline_result: MazeDataset,
    reference: MazeDataset,
) -> None:
    """Per-unit 1D rate maps must match."""
    for uid in reference.unit_results:
        ref_map = reference.unit_results[uid].rate_map
        got_map = pipeline_result.unit_results[uid].rate_map
        assert got_map.shape == ref_map.shape, f"unit {uid} rate_map shape"
        np.testing.assert_allclose(
            got_map,
            ref_map,
            rtol=1e-5,
            atol=1e-10,
            equal_nan=True,
            err_msg=f"unit {uid} rate_map",
        )
